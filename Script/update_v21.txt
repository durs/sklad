SET TERM ^ ;

CREATE PROCEDURE UPDATE_TRANSPORT (
    DOCID INTEGER,
    SUM3 NUMERIC(15,2))
AS
DECLARE VARIABLE NDS DOUBLE PRECISION;
DECLARE VARIABLE NDSSUM DOUBLE PRECISION;
DECLARE VARIABLE ISREC INTEGER;
BEGIN
  /* search transport rec */
  ISREC = 0;
  IF (EXISTS(SELECT * FROM DOC_PROD WHERE DOCID = :DOCID AND RECID = -1)) THEN ISREC = 1;

  /* delete transport rec*/
  IF (ISREC > 0 AND (SUM3 IS NULL OR SUM3 <= 0)) THEN BEGIN
    DELETE FROM DOC_PROD WHERE DOCID = :DOCID AND RECID = -1;
  END

  /* insert or upate transport rec*/
  ELSE IF (SUM3 IS NOT NULL AND SUM3 > 0) THEN BEGIN
    /* calculate NDS for transport */
    SELECT NDS FROM PRODUCT WHERE PRODID = -1 INTO :NDS;
    IF (NDS IS NULL OR NDS < 0) THEN NDS = 0;
    NDSSUM = SUM3 * (NDS/(100+NDS));

    /* update rec */
    IF (ISREC > 0) THEN UPDATE DOC_PROD SET CNT = 1, UNIT = 1, PRICE = :SUM3, NDSPRICE = :NDSSUM, NALOGSUM = 0 WHERE DOCID = :DOCID AND RECID = -1;

    /* insert rec */
    ELSE INSERT INTO DOC_PROD (DOCID, RECID, PRODID, CNT, UNIT, INPRICE, INNDSPRICE, OUTPRICE, PRICE, NDSPRICE, NEWPRICE, NEWPRICE2, NEWPRICE3, NALOGSUM) VALUES (:DOCID, -1, -1, 1, 1, 0, 0, 0, :SUM3, :NDSSUM, 0, 0, 0, 0);
  END
END
^


CREATE PROCEDURE CORRECT_TRANSPORT 
AS
DECLARE VARIABLE DOCID INTEGER;
DECLARE VARIABLE SUM3 NUMERIC(15,2);
BEGIN
  FOR SELECT DOCID, SUM3 FROM DOC WHERE SUM3 IS NOT NULL AND SUM3 > 0 INTO :DOCID, :SUM3
  DO
    EXECUTE PROCEDURE UPDATE_TRANSPORT(DOCID, SUM3);
END
^


ALTER PROCEDURE QUERY_OSTATOK (
    ID INTEGER,
    ID2 INTEGER)
RETURNS (
    INDOCID INTEGER,
    INRECID INTEGER,
    PDOCID INTEGER,
    PRECID INTEGER,
    PRODID INTEGER,
    DATE1 TIMESTAMP,
    CNT DOUBLE PRECISION,
    UNIT DOUBLE PRECISION,
    INPRICE DOUBLE PRECISION,
    INNDSPRICE DOUBLE PRECISION,
    OUTPRICE DOUBLE PRECISION,
    OUTPRICE2 DOUBLE PRECISION,
    OUTPRICE3 DOUBLE PRECISION,
    PRODUCTNAME VARCHAR(50),
    CLASSNAME VARCHAR(10),
    PRODUSERNAME VARCHAR(10),
    PRODUCT VARCHAR(100),
    DIM VARCHAR(10),
    LEN VARCHAR(10),
    WEIGHT FLOAT,
    LASTPRICE DOUBLE PRECISION,
    NDS FLOAT,
    COUNTRY VARCHAR(50),
    NTD BLOB SUB_TYPE 0 SEGMENT SIZE 80,
    SERTIFICAT BLOB SUB_TYPE 0 SEGMENT SIZE 80,
    COMMENT BLOB SUB_TYPE 0 SEGMENT SIZE 80)
AS
BEGIN
  IF (ID IS NULL) THEN
    FOR SELECT
      PRODUCT.PRODID, PRODUCT.UNIT, PRODUCT.NDS, PRODUCT.NAME, PRODUCT.DIM, PRODUCT.LEN, PRODUCT.WEIGHT, PRODUCT.PRICE, PRODUCT.COMMENT, PRODUCT.SERTIFICAT,
      CLASS.SMALLNAME,
      PRODUSER.SMALLNAME, PRODUSER.COUNTRY,
      GET_PRODUCT_NAME(PRODUCT.NAME, CLASS.SMALLNAME, PRODUSER.SMALLNAME, PRODUCT.LEN)
    FROM PRODUCT
    LEFT JOIN CLASS ON CLASS.CLASSID = PRODUCT.CLASSID
    LEFT JOIN PRODUSER ON PRODUSER.PRODUSERID = PRODUCT.PRODUSERID
    WHERE PRODUCT.PRODID > 0
    ORDER BY PRODUCT.NAME, PRODUCT.CLASSID, PRODUCT.PRODUSERID, PRODUCT.LEN
    INTO :PRODID, :UNIT, :NDS, :PRODUCTNAME, :DIM, :LEN, :WEIGHT, :LASTPRICE, :COMMENT, :SERTIFICAT, :CLASSNAME, :PRODUSERNAME, :COUNTRY, :PRODUCT
    DO SUSPEND;
  ELSE IF (ID2 IS NULL) THEN
    FOR SELECT
      DOC_PROD.DOCID, DOC_PROD.RECID, DOC_PROD.PRODID, DOC_PROD.CNT - DOC_PROD.RCNT - DOC_PROD.UCNT, DOC_PROD.UNIT, DOC_PROD.PRICE, DOC_PROD.NDSPRICE, DOC_PROD.NEWPRICE, DOC_PROD.NEWPRICE2, DOC_PROD.NEWPRICE3, DOC_PROD.NTD, DOC_PROD.COMMENT,
      DOC_PROD.DATE1,
      PRODUCT.NDS, PRODUCT.NAME, PRODUCT.DIM, PRODUCT.LEN, PRODUCT.WEIGHT, PRODUCT.PRICE, PRODUCT.SERTIFICAT,
      CLASS.SMALLNAME,
      PRODUSER.SMALLNAME, PRODUSER.COUNTRY,
      GET_PRODUCT_NAME(PRODUCT.NAME, CLASS.SMALLNAME, PRODUSER.SMALLNAME, PRODUCT.LEN)
    FROM DOC_PROD
    /*INNER JOIN DOC ON DOC.DOCID=DOC_PROD.DOCID AND DOC.CLIENTID2=:ID AND DOC.KIND=1*/
    LEFT JOIN PRODUCT ON PRODUCT.PRODID = DOC_PROD.PRODID
    LEFT JOIN CLASS ON CLASS.CLASSID = PRODUCT.CLASSID
    LEFT JOIN PRODUSER ON PRODUSER.PRODUSERID = PRODUCT.PRODUSERID
    WHERE DOC_PROD.KIND = 0 AND DOC_PROD.CLIENTID2 = :ID AND DOC_PROD.RECID > 0
    ORDER BY PRODUCT.NAME, PRODUCT.CLASSID, PRODUCT.PRODUSERID, PRODUCT.LEN, DOC_PROD.DATE1
    INTO :INDOCID, :INRECID, :PRODID, :CNT, :UNIT, :INPRICE, :INNDSPRICE, :OUTPRICE, :OUTPRICE2, :OUTPRICE3, :NTD, :COMMENT, :DATE1, :NDS, :PRODUCTNAME, :DIM, :LEN, :WEIGHT, :LASTPRICE, :SERTIFICAT, :CLASSNAME, :PRODUSERNAME, :COUNTRY, :PRODUCT
    DO SUSPEND;
  ELSE
    FOR SELECT
      DOC_PROD.DOCID, DOC_PROD.RECID, DOC_PROD.INDOCID, DOC_PROD.INRECID,
      DOC_PROD.PRODID, DOC_PROD.CNT - DOC_PROD.RCNT - DOC_PROD.UCNT, DOC_PROD.UNIT, DOC_PROD.INPRICE, DOC_PROD.INNDSPRICE, DOC_PROD.PRICE, DOC_PROD.NTD, DOC_PROD.COMMENT,
      DOC.DATE1,
      PRODUCT.NDS, PRODUCT.NAME, PRODUCT.DIM, PRODUCT.LEN, PRODUCT.WEIGHT, PRODUCT.PRICE, PRODUCT.SERTIFICAT,
      CLASS.SMALLNAME,
      PRODUSER.SMALLNAME, PRODUSER.COUNTRY,
      GET_PRODUCT_NAME(PRODUCT.NAME, CLASS.SMALLNAME, PRODUSER.SMALLNAME, PRODUCT.LEN)
    FROM DOC_PROD
    INNER JOIN DOC ON DOC.DOCID = DOC_PROD.DOCID AND DOC.CLIENTID1 = :ID AND DOC.CLIENTID2 = :ID2 AND DOC.KIND = 1
    LEFT JOIN PRODUCT ON PRODUCT.PRODID = DOC_PROD.PRODID
    LEFT JOIN CLASS ON CLASS.CLASSID = PRODUCT.CLASSID
    LEFT JOIN PRODUSER ON PRODUSER.PRODUSERID = PRODUCT.PRODUSERID
    WHERE DOC_PROD.KIND = 0 AND DOC_PROD.RECID > 0
    ORDER BY PRODUCT.NAME, PRODUCT.CLASSID, PRODUCT.PRODUSERID, PRODUCT.LEN, DOC.DATE1 DESC
    INTO :PDOCID, :PRECID, :INDOCID, :INRECID, :PRODID, :CNT, :UNIT, :INPRICE, :INNDSPRICE, :OUTPRICE, :NTD, :COMMENT, :DATE1, :NDS, :PRODUCTNAME, :DIM, :LEN, :WEIGHT, :LASTPRICE, :SERTIFICAT, :CLASSNAME, :PRODUSERNAME, :COUNTRY, :PRODUCT
    DO SUSPEND;
END
^


ALTER PROCEDURE QUERY_OSTATOK2 (
    CLIENTID INTEGER,
    FIRSTDOCDATE TIMESTAMP,
    FIRSTDATE TIMESTAMP,
    LASTDATE TIMESTAMP)
RETURNS (
    INDOCID INTEGER,
    INRECID INTEGER,
    PRODID INTEGER,
    INCNT DOUBLE PRECISION,
    OUTCNT DOUBLE PRECISION,
    CNT DOUBLE PRECISION,
    VCNT DOUBLE PRECISION,
    UNIT DOUBLE PRECISION,
    INPRICE DOUBLE PRECISION,
    INNDSPRICE DOUBLE PRECISION,
    OUTPRICE DOUBLE PRECISION,
    OUTSUM DOUBLE PRECISION,
    OUTNDSSUM DOUBLE PRECISION,
    OUTNALOGSUM DOUBLE PRECISION,
    ISOST SMALLINT)
AS
DECLARE VARIABLE E DOUBLE PRECISION;
DECLARE VARIABLE KIND INTEGER;
DECLARE VARIABLE RCNT DOUBLE PRECISION;
DECLARE VARIABLE INNERCNT DOUBLE PRECISION;
DECLARE VARIABLE PRICE DOUBLE PRECISION;
DECLARE VARIABLE NDSPRICE DOUBLE PRECISION;
DECLARE VARIABLE DATE1 DATE;
BEGIN
  E = 0.00001;
  SELECT KIND FROM SKLAD WHERE CLIENTID = :CLIENTID INTO :KIND;
  IF (KIND IS NULL) THEN KIND = 0;

  FOR SELECT DOC.DATE1, DOC_PROD.DOCID, DOC_PROD.RECID, DOC_PROD.PRODID,
    DOC_PROD.CNT, DOC_PROD.UNIT, 
    DOC_PROD.INPRICE, DOC_PROD.INNDSPRICE, DOC_PROD.PRICE, DOC_PROD.NDSPRICE, DOC_PROD.NEWPRICE
    FROM DOC,DOC_PROD
    WHERE DOC.CLIENTID2 = :CLIENTID AND DOC.KIND = 1
    AND (:FIRSTDOCDATE IS NULL OR DOC.DATE1 >= :FIRSTDOCDATE) AND (:LASTDATE IS NULL OR DOC.DATE1 <= :LASTDATE)
    AND DOC_PROD.DOCID = DOC.DOCID AND DOC_PROD.RECID > 0
    ORDER BY 1, 2, 3, 4
    INTO :DATE1, :INDOCID, :INRECID, :PRODID, :INCNT, :UNIT, :INPRICE, :INNDSPRICE, :PRICE, :NDSPRICE, :OUTPRICE
  DO IF (INCNT >= 0 OR (FIRSTDATE IS NOT NULL AND DATE1 >= FIRSTDATE)) THEN BEGIN

    IF (KIND <> 1) THEN BEGIN
      INPRICE = :PRICE;
      INNDSPRICE = :NDSPRICE;
    END

    IF (FIRSTDATE IS NULL OR DATE1 < FIRSTDATE) THEN ISOST = 1; ELSE ISOST = 0;

    /*GET VOZVRAT COUNT BEFORE FIRSTDATE*/
    SELECT SUM(DOC_PROD.CNT * DOC_PROD.UNIT)
    FROM DOC_PROD
    LEFT JOIN DOC ON DOC.DOCID = DOC_PROD.DOCID
    WHERE DOC_PROD.PDOCID = :INDOCID AND DOC_PROD.PRECID = :INRECID
    AND (:FIRSTDATE IS NULL OR DOC.DATE1 < :FIRSTDATE)
    AND (:LASTDATE IS NULL OR DOC.DATE1 < :LASTDATE)
    AND DOC.KIND = 1
    INTO :VCNT;
    IF (VCNT IS NULL) THEN VCNT = 0; ELSE VCNT = VCNT / UNIT;
    INCNT = INCNT + VCNT; /*Append 20.01.2004*/

    /*GET ALL RELEASE COUNT*/
    SELECT SUM(DOC_PROD.CNT * DOC_PROD.UNIT)
      FROM DOC_PROD
      LEFT JOIN DOC ON DOC.DOCID = DOC_PROD.DOCID
      WHERE DOC_PROD.INDOCID = :INDOCID AND DOC_PROD.INRECID = :INRECID
      AND (:LASTDATE IS NULL OR DOC.DATE1 <= :LASTDATE)
      AND DOC.KIND = 1
      INTO :RCNT;
    IF (RCNT IS NULL) THEN RCNT = 0; ELSE RCNT = RCNT / UNIT;
    CNT = INCNT - RCNT;

    /*GET RELEASE COUNT AFTER FIRSTDATE*/
    IF (RCNT <> 0 AND FIRSTDATE IS NOT NULL) THEN BEGIN
      SELECT SUM(DOC_PROD.CNT * DOC_PROD.UNIT),
        SUM(ROUND_CURR(DOC_PROD.CNT * DOC_PROD.UNIT * DOC_PROD.PRICE)), SUM(ROUND_CURR(DOC_PROD.CNT * DOC_PROD.UNIT * DOC_PROD.NDSPRICE)), SUM(DOC_PROD.NALOGSUM)
        FROM DOC_PROD
        LEFT JOIN DOC ON DOC.DOCID = DOC_PROD.DOCID
        WHERE DOC_PROD.INDOCID = :INDOCID AND DOC_PROD.INRECID = :INRECID
        AND DOC.DATE1 >= :FIRSTDATE AND (:LASTDATE IS NULL OR DOC.DATE1 <= :LASTDATE)
        AND DOC.KIND = 1 /* AND DOC.SKIND>0 */
        INTO :OUTCNT, :OUTSUM, :OUTNDSSUM, :OUTNALOGSUM;
      IF (OUTCNT IS NULL) THEN OUTCNT = 0; ELSE OUTCNT = OUTCNT / UNIT;
      IF (OUTSUM IS NULL) THEN OUTSUM = 0;
      IF (OUTNDSSUM IS NULL) THEN OUTNDSSUM = 0;
      IF (OUTNALOGSUM IS NULL) THEN OUTNALOGSUM = 0;
      INCNT = CNT + OUTCNT;
      IF (CNT/* + VCNT*/ < -E OR CNT/* + VCNT*/ > E OR OUTCNT < -E OR OUTCNT > E OR OUTSUM < -E OR OUTSUM > E) THEN SUSPEND;
      /*Correct 20.01.2004*/
    END ELSE BEGIN
      OUTCNT = 0; OUTSUM = 0; OUTNDSSUM = 0; OUTNALOGSUM = 0;
      IF (CNT/* + VCNT*/ < -E OR CNT/* + VCNT*/ > E) THEN SUSPEND;
      /*Correct 20.01.2004*/
    END
  END
END
^


ALTER TRIGGER DOC_BEFOREINSERT
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  /* correct field values */
  IF (NEW.CLIENTID1 IS NULL) THEN NEW.CLIENTID1 = 0;
  IF (NEW.CLIENTID2 IS NULL) THEN NEW.CLIENTID2 = 0;
  IF (NEW.CLIENTID1 = NEW.CLIENTID2) THEN NEW.CLIENTID2=0;
  IF (NEW.SUM0 IS NULL) THEN NEW.SUM0 = 0;
  IF (NEW.SUM3 IS NULL) THEN NEW.SUM3 = 0;

  /* test reg */
  IF (GEN_ID(GENREG, 0) > 0) THEN BEGIN IF (GEN_ID(GENREG, 1) > 5000) THEN EXCEPTION E_REG; END

  /*update doc no*/
  EXECUTE PROCEDURE UPDATE_DOCNO NEW.CLIENTID1, NEW.KIND, NEW.SKIND, NEW.DOCNO, NEW.SUM0, 0 
  RETURNING_VALUES NEW.DOCNO;

  /*update debit*/
  IF (NEW.KIND < 256) THEN BEGIN
    EXECUTE PROCEDURE UPDATE_DEBIT NEW.DOCID, NEW.PDOCID, NEW.CLIENTID1, NEW.CLIENTID2, NEW.SUM0
    RETURNING_VALUES NEW.OST;
  END 
  ELSE BEGIN
    NEW.OST = NEW.SUM0;
  END

  /*update transport rec doc_prod*/
  IF (NEW.SUM3 <> 0) THEN
    EXECUTE PROCEDURE UPDATE_TRANSPORT NEW.DOCID, NEW.SUM3;
END
^


ALTER TRIGGER DOC_BEFOREUPDATE
ACTIVE BEFORE UPDATE POSITION 0
AS
DECLARE VARIABLE DIFF DOUBLE PRECISION;
BEGIN
  /* correct field values */
  IF (NEW.CLIENTID1 IS NULL) THEN NEW.CLIENTID1 = 0;
  IF (NEW.CLIENTID2 IS NULL) THEN NEW.CLIENTID2 = 0;
  IF (NEW.CLIENTID1 = NEW.CLIENTID2) THEN NEW.CLIENTID2 = 0;
  IF (NEW.SUM0 IS NULL) THEN NEW.SUM0 = 0;
  IF (NEW.SUM3 IS NULL) THEN NEW.SUM3 = 0;
  IF (NEW.OST IS NULL) THEN NEW.OST = 0;

  /* test field values */
  /*IF (OLD.KIND>512) THEN EXCEPTION E_ARCHIV;*/
  IF (OLD.DOCID <> NEW.DOCID) THEN EXCEPTION E_FIELD_UPDATE;
  IF (OLD.CLIENTID1 <> NEW.CLIENTID1) THEN BEGIN
    /* except sklad */
    IF (EXISTS(SELECT * FROM DOC_PROD WHERE DOCID = OLD.DOCID)) THEN
    IF (EXISTS(SELECT * FROM SKLAD WHERE CLIENTID = NEW.CLIENTID1 OR CLIENTID = OLD.CLIENTID1))
    /*IF (EXISTS(SELECT * FROM DOC_PROD WHERE DOCID = OLD.DOCID AND INDOCID IS NOT NULL))*/
    THEN EXCEPTION E_FIELD_UPDATE;
  END
  IF (OLD.CLIENTID2 <> NEW.CLIENTID2) THEN BEGIN
    IF (EXISTS(SELECT * FROM DOC_PROD WHERE INDOCID = OLD.DOCID)) THEN EXCEPTION E_FIELD_UPDATE;
  END

  /*update doc no*/
  EXECUTE PROCEDURE UPDATE_DOCNO OLD.CLIENTID1, OLD.KIND, OLD.SKIND, OLD.DOCNO, OLD.SUM0, 1 RETURNING_VALUES OLD.DOCNO;
  EXECUTE PROCEDURE UPDATE_DOCNO NEW.CLIENTID1, NEW.KIND, NEW.SKIND, NEW.DOCNO, NEW.SUM0, 0 RETURNING_VALUES NEW.DOCNO;

  /*update debit*/
  IF ((OLD.KIND < 256 AND NEW.KIND > 256) OR (OLD.CLIENTID1 <> NEW.CLIENTID1) OR (OLD.CLIENTID2 <> NEW.CLIENTID2)) THEN BEGIN
    /*delete debit*/
    DIFF = OLD.OST - OLD.SUM0;
    EXECUTE PROCEDURE UPDATE_DEBIT_UNDO OLD.DOCID, OLD.PDOCID, OLD.CLIENTID1, OLD.CLIENTID2, :DIFF;
    NEW.OST = NEW.SUM0;
  END 
  ELSE IF ((OLD.KIND > 256 AND NEW.KIND < 256) OR (OLD.CLIENTID1 <> NEW.CLIENTID1) OR (OLD.CLIENTID2 <> NEW.CLIENTID2)) THEN BEGIN
    /*insert debit*/
    EXECUTE PROCEDURE UPDATE_DEBIT NEW.DOCID, NEW.PDOCID, NEW.CLIENTID1, NEW.CLIENTID2, NEW.SUM0
    RETURNING_VALUES NEW.OST;    
  END 
  ELSE IF (NEW.KIND < 256) THEN BEGIN
    /*update debit*/
    IF (OLD.SUM0 IS NULL) THEN DIFF = NEW.SUM0; ELSE DIFF=NEW.SUM0-OLD.SUM0;
    IF (DIFF<>0) THEN BEGIN
      IF (OLD.OST IS NULL) THEN NEW.OST = DIFF; ELSE NEW.OST = OLD.OST+DIFF;
      EXECUTE PROCEDURE UPDATE_DEBIT NEW.DOCID, NEW.PDOCID, NEW.CLIENTID1, NEW.CLIENTID2, NEW.OST
      RETURNING_VALUES NEW.OST;
      DIFF = 0;
      IF (NEW.SUM0 > 0) THEN BEGIN
        IF (NEW.OST < 0) THEN BEGIN
          DIFF = NEW.OST;
          NEW.OST = 0;
        END 
        ELSE IF (NEW.OST > NEW.SUM0) THEN BEGIN
          DIFF = NEW.OST - NEW.SUM0;
          NEW.OST = NEW.SUM0;
        END
      END 
      ELSE BEGIN
        IF (NEW.OST > 0) THEN BEGIN
          DIFF = NEW.OST;
          NEW.OST = 0;          
        END 
        ELSE IF (NEW.OST < NEW.SUM0) THEN BEGIN
          DIFF = NEW.OST - NEW.SUM0;
          NEW.OST = NEW.SUM0;
        END
      END
      IF (DIFF <> 0) THEN EXECUTE PROCEDURE UPDATE_DEBIT_UNDO NEW.DOCID, NEW.PDOCID, NEW.CLIENTID1, NEW.CLIENTID2, :DIFF;
    END
  END
  ELSE BEGIN
    NEW.OST = NEW.SUM0;
  END

  /*update transport rec doc_prod*/
  IF (NEW.SUM3 <> OLD.SUM3) THEN
    EXECUTE PROCEDURE UPDATE_TRANSPORT NEW.DOCID, NEW.SUM3;

  /*update doc_prod*/
  IF (NEW.CLIENTID2 <> OLD.CLIENTID2 OR NEW.DATE1 <> OLD.DATE1) THEN
    UPDATE DOC_PROD SET CLIENTID2 = NEW.CLIENTID2, DATE1 = NEW.DATE1 WHERE DOCID = NEW.DOCID;
END
^

SET TERM ; ^
COMMIT WORK;
EXECUTE PROCEDURE GET_VERSION(1);
COMMIT WORK;

EXECUTE PROCEDURE CORRECT_TRANSPORT;
COMMIT WORK;